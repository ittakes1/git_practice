# git_practice

repository, repo: 倉庫

commit: 遞交 提交

staged: 預存 暫存

## 初始設定
安裝以後，設定使用者名稱和email
```bash
$ git config --global user.name "John Doe"
$ git config --global user.email johndoe@example.com
```
其他設定
```
$ git config --global core.editor vim
$ git config --global merge.tool=vimdiff
```

### 列出個人設定
```bash
git config --list
```
git config --list命令列出所有 Git 在目前位置能找到的設定值:

### 三種取得 Git 命令說明文件的方法:
```bash
$ git help <verb>
$ git <verb> --help
$ man git-<verb>
```
例如 $git help config

## 建立專案

1. 把現有專案匯入到git中

2. 從伺服器上複製現有的Git倉庫

### 1. 把現有專案匯入到git中
在專案目錄底下：
```
$ git init
```
開始追蹤目錄底下所有檔案：
```
git add .
```
遞交commit
```
git commit -m "關於這次變更的敘述"
```

### 2. 複製現有倉庫

git clone 下載遠端repo

1. 使用https
```
$ git clone https://github.com/ittakes1/git_practice.git git_practice
```
說明 git clone https://網址/帳號名/項目名.git 目錄名
目錄名可以自行設定，如果不寫，項目名就是項目名

2. 使用ssh
```
$ git clone git@github.com:ittakes1/git_practice.git
```
說明 git clone git@網址:帳號名/項目名.git

## Git倉庫中記錄變更

工作目錄下的每一個檔案不是tracked已追蹤就是untracked未追蹤

已追蹤的檔案三種狀態
1. 已修改
2. 未修改
3. 已預存


### git add 命令追蹤單一的新檔案
要開始追蹤一個新的檔案,可以使用 git add 命令; 要開始追蹤 README 檔案,你可以執行:
```bash
$ git add README.md
```

### git status 命令檢查狀態
如果再次執行檢查狀態命令,可以看到 README.md 檔案現在是準備好被提交的「已追蹤」和「已預存」狀態:
```bash
$ git status
```
輸出
```
On branch master
Your branch is up-to-date with 'origin/master'.
```
簡潔版本: `git status -s`


## 預存修改過的檔案 git add

### 提交你的修改
現在你的預存區已被建構成你想要的，你可以開始提交你的變更； 記住：任何未預暫存的檔案——新增的、已修改的，自從你編輯它們卻尚未用 git add 預存的——將不會納入本次的提交中； 它們仍以「已修改」的身份存在磁碟中。 在目前情況下，假設你上次執行 git status 時，你看到所有檔案都已經被預存，因此你準備提交你的變更。 最簡單的提交方式是輸入 git commit：
```bash
$ git commit  # 這麼做會啟動你選定的編輯器
```
或者
```
$ git commit -m "Story 182: Fix benchmarks for speed" # -m 選項後方直接輸入提交訊息
[master 463dc4f] Story 182: Fix benchmarks for speed  
2 files changed, 2 insertions(+) 
create mode 100644 README
```
[master 463dc4f] Story 182: Fix benchmarks for speed  

提交到哪個分支（master）、提交的 SHA-1 校驗碼（463dc4f）

2 files changed, 2 insertions(+) 

有多少檔案被更動，以及統計此提交有多少列被新增和被移除

### 略過預存 git add + git commit一起用
在 git commit 命令加上 -a 選項，使 Git 在提交前自動預存所有已追蹤的檔案，讓你略過 git add 步驟：`
```
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
1 file changed, 5 insertions(+), 0 deletions(-)
```

## 將變更發送到遠端repo (例如github.com)
```bash
$ git push origin master
```

## 忽略檔案 .gitignore檔案
gitignore - Specifies intentionally untracked files to ignore

* Patterns which should be version-controlled and distributed to other repositories via clone (i.e., files that all developers will want to ignore) should go into a `.gitignore` file.

* Patterns which are specific to a particular repository but which do not need to be shared with other related repositories (e.g., auxiliary files that live inside the repository but are specific to one user’s workflow) should go into the `$GIT_DIR/info/exclude` file.

* Patterns which a user wants Git to ignore in all situations (e.g., backup or temporary files generated by the user’s editor of choice) generally go into a file specified by core.excludesFile in the user’s ~/.gitconfig. Its default value is $XDG_CONFIG_HOME/git/ignore. If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/ignore is used instead.

### PATTERN FORMAT

* 空白行不處理

* 以#開頭表示註解 Put a backslash ("\") in front of the first hash for patterns that begin with a hash.

* 後綴空白不處理 unless they are quoted with backslash ("\").

* !邏輯非 which negates the pattern; any matching file excluded by a previous pattern will become included again. It is not possible to re-include a file if a parent directory of that file is excluded. Git doesn’t list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined. Put a backslash ("\") in front of the first "!" for patterns that begin with a literal "!", for example, "\!important!.txt".

* 目錄分隔符號/ is used as the directory separator. Separators may occur at the beginning, middle or end of the .gitignore search pattern.

* 以/開頭以避免路徑遞迴。（只忽略特定路徑；如果不以斜線開頭，則不管同名檔案或同名資料夾在哪一層都會被忽略。）

* 以/結尾代表是目錄。

* glob模式： *, [abc], ?


## 檢視已預存和未預存檔案的變更 git diff

檢視尚未預存的變更

想瞭解尚未預存的修改，輸入不帶其它參數的 git diff 這命令會比對「工作目錄」和「預存區」之間的版本， 然後顯示尚未被存入預存區的修改內容。
```
$ git diff
```

檢視已預存的變更

如果你想檢視你已經預存而接下來將會被提交的內容，可以使用 git diff --staged； 這個命令比對的對象是「預存區」和「最後一次提交」
```
$ git diff --staged
```

使用外部工具
```
git difftool --tool-help
git difftool --tool=vimdiff
```

## 移除檔案

要從 Git 中刪除一個檔案，你需要將它從已追蹤檔案中移除（更準確地說，是從預存區中移除），然後再提交； git rm 命令可完成此工作，它同時也會將該檔案從工作目錄中移除，如此它之後也不會身為未追蹤檔案而被你看到
```
$ git rm PROJECTS.md
```

## 看歷史記錄
### 看log
最新的在上面
```
git log

git log --pretty=short

git log --graph 圖示分支
```

### 看分支 git branch

git branch

git branch -a 顯示local and remote
創建,切換分支 git checkout -b

git checkout -b list-dict 等於 git branch list-dict 加 git checkout list-dict
切換到分支

git checkout master 到master

git checkout - 到上一個
合併分支 list-dict 到 master

git checkout master

git merge —no-ff list-dict
回溯舊版 git reset

看log

git reflog


## 使用遠端倉庫，與他人協作

### 顯示遠端倉庫

git remote

### 增加遠端倉庫
git remote add [shortname] [url]


### 擷取資料
git fetch [remote-name]

git fetch 只會把資料擷取到本機倉庫，不會自動合併資料，也不會動目錄下資料

git pull 自動取得遠端資料，並且合併入本機分支

### 發送資料到遠端倉庫
git push origin master

前提

1. 有權寫入
2. 沒別人早於你發送, 否則要處理合併衝突

### 檢查遠端倉庫
git remote show origin

### 刪除，改名遠端倉庫
git remote rename
git remote rm

## 標記 將特定歷史版本標記為重要版本

### 列舉標籤
git tag

### 建立標籤

* lightweight 輕量標籤

可以視為不變的分支

* annotated 註釋標籤

計算校正碼，記錄標記者名字，標記訊息...


### 註釋標籤
git tag -a v1.0 -m "版本 1.0"
git tag
git show v1.0

### 輕量標籤
git tag v1.0-1w
git tag

### 補加標籤
git log --pretty=oneline
git tag -a v0.8xxxxx(校正碼)

## git 別名
git config --global alias.ci checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.last 'log -l HEAD'
...


## 分支機制

Git 保存的不是變更集或者差異內容，而是一系列快照。當發起提交時，Git儲存的是物件commit object，該物件內容包含一個指標，用來代表已預存的快照內容； 這個物件內容還包含「作者名字和電子郵件」、「你輸入的訊息內容」、「指向前一個提交的指標（該提交的親代提交）」：沒有親代（parent）提交表示它是初始的第一個提交，一般情況下只有一個親代提交，超過一個親代提交表示它是從二個以上的分支合併而來的。


你的 Git 版本庫現在有五個物件：三個 blob 物件用來儲存檔案內容、一個樹物件用來列出目錄的內容並紀錄各個檔案所對應的 blob 物件、一個提交用來記錄根目錄的樹物件和其他提交資訊。


![alt text][1]

[1]: ./commit-and-tree.png "test"

如果你做一些修改並再次提交，這次的提交會再包含一個指向上次提交的指標（譯注：即下圖中的 parent 欄位）。

![alt text][2]

[2]: ./commits-and-parents.png

Git 分支其實只是一個指向某提交的可移動輕量級指標， Git 預設分支名稱是 master， 隨著不斷地製作提交，master 分支會為你一直指向最後一個提交， 它在每次提交的時候都會自動向前移動。

![alt text][3]

[3]:./branch-and-history.png

### 建立新分支

建立一個新分支會發生什麼事呢？ 答案很簡單，建立一個新的、可移動的指標； 比如新建一個 testing 分支， 可以使用 git branch 命令：
```
$ git branch testing
```
這會在目前提交上新建一個指標。

![](./two-branches.png)

Git 如何知道你目前在哪個分支上工作的呢？ 其實它保存了一個名為 HEAD 的特別指標； 在 Git 中，它就是一個指向你正在工作中的本地分支的指標， 所以在這個例子中，你仍然在 master 分支上工作； 執行 git branch 命令，只是「建立」一個新的分支——它並不會切換到這個分支。

![](./head-to-master.png)

你可以很輕鬆地看到分支指標指向何處，只需透過一個簡單的 git log 命令， 加上 --decorate 選項。
```
$ git log --oneline --decorate
f30ab (HEAD -> master, testing) add feature #32 - ability to add new formats to the central interface
34ac2 Fixed bug #1328 - stack overflow under certain conditions
98ca9 The initial commit of my project
```
你可以看到「master」和「testing」分支就顯示在 f30ab 提交旁邊。

### 在分支之間切換
要切換到一個已經存在的分支，你可以執行 git checkout 命令， 讓我們切換到新的 testing 分支：
```
$ git checkout testing
```
這會移動 HEAD 並指向 testing 分支。

![](./head-to-testing.png)


### 合併衝突處理
```
$ git status
On branch master
Your branch and 'origin/master' have diverged,
and have 2 and 10 different commits each, respectively.
  (use "git pull" to merge the remote branch into yours)

You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Changes to be committed:
	new file:   .gitignore
	new file:   Markdown.md

Unmerged paths:
  (use "git add <file>..." to mark resolution)
	both modified:   README.md
```

以git merge處理衝突
